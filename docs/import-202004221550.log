From 06e8676dcdfee3c1e46e18c437eec3ca4fc18821 Mon Sep 17 00:00:00 2001
From: Ambriel Skoeld <ambriel.archangel@icloud.com>
Date: Wed, 22 Apr 2020 15:49:05 +0000
Subject: [PATCH] Gemfile .rspec Guardfile Rakefile build and code codeaurora

---
 .gitignore                            |   3 +++
 .rspec                                |   1 +
 Gemfile                               |  11 +++++++++++
 Guardfile                             |  11 +++++++++++
 README.md                             |  71 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Rakefile                              |   9 +++++++++
 lib/omniauth-ldap.rb                  |   4 ++++
 lib/omniauth-ldap/adaptor.rb          | 147 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 lib/omniauth-ldap/version.rb          |   5 +++++
 lib/omniauth/strategies/ldap.rb       | 101 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 omniauth-ldap.gemspec                 |  26 ++++++++++++++++++++++++++
 spec/omniauth-ldap/adaptor_spec.rb    |  86 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 spec/omniauth/strategies/ldap_spec.rb | 200 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 spec/spec_helper.rb                   |  14 ++++++++++++++
 14 files changed, 689 insertions(+)
 create mode 100644 .gitignore
 create mode 100644 .rspec
 create mode 100644 Gemfile
 create mode 100644 Guardfile
 create mode 100644 README.md
 create mode 100644 Rakefile
 create mode 100644 lib/omniauth-ldap.rb
 create mode 100644 lib/omniauth-ldap/adaptor.rb
 create mode 100644 lib/omniauth-ldap/version.rb
 create mode 100644 lib/omniauth/strategies/ldap.rb
 create mode 100644 omniauth-ldap.gemspec
 create mode 100644 spec/omniauth-ldap/adaptor_spec.rb
 create mode 100644 spec/omniauth/strategies/ldap_spec.rb
 create mode 100644 spec/spec_helper.rb

diff --git a/.gitignore b/.gitignore
new file mode 100644
index 0000000..3b653ef
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1,3 @@
+.project
+coverage
+/Gemfile.lock
diff --git a/.rspec b/.rspec
new file mode 100644
index 0000000..53607ea
--- /dev/null
+++ b/.rspec
@@ -0,0 +1 @@
+--colour
diff --git a/Gemfile b/Gemfile
new file mode 100644
index 0000000..339f969
--- /dev/null
+++ b/Gemfile
@@ -0,0 +1,11 @@
+source 'http://rubygems.org'
+
+gemspec
+
+group :development, :test do
+  gem 'guard'
+  gem 'guard-rspec'
+  gem 'guard-bundler'
+  gem 'growl'
+  gem 'rb-fsevent'
+end
diff --git a/Guardfile b/Guardfile
new file mode 100644
index 0000000..df36f0d
--- /dev/null
+++ b/Guardfile
@@ -0,0 +1,11 @@
+guard 'rspec', :version => 2 do
+  watch(%r{^spec/.+_spec\.rb$})
+  watch(%r{^lib/(.+)\.rb$})     { |m| "spec/#{m[1]}_spec.rb" }
+  watch('spec/spec_helper.rb')  { "spec" }
+end
+
+
+guard 'bundler' do
+  watch('Gemfile')
+  watch(/^.+\.gemspec/)
+end
diff --git a/README.md b/README.md
new file mode 100644
index 0000000..7b3019f
--- /dev/null
+++ b/README.md
@@ -0,0 +1,71 @@
+# OmniAuth LDAP
+
+== LDAP
+
+Use the LDAP strategy as a middleware in your application:
+
+    use OmniAuth::Strategies::LDAP, 
+        :title => "My LDAP", 
+        :host => '10.101.10.1',
+        :port => 389,
+        :method => :plain,
+        :base => 'dc=intridea, dc=com',
+        :uid => 'sAMAccountName',
+        :name_proc => Proc.new {|name| name.gsub(/@.*$/,'')},
+        :bind_dn => 'default_bind_dn',
+        # Or, alternatively:
+        #:filter => '(&(uid=%{username})(memberOf=cn=myapp-users,ou=groups,dc=example,dc=com))'
+        :name_proc => Proc.new {|name| name.gsub(/@.*$/,'')}
+        :bind_dn => 'default_bind_dn'
+        :password => 'password'
+
+All of the listed options are required, with the exception of :title, :name_proc, :bind_dn, and :password.
+Allowed values of :method are: :plain, :ssl, :tls.
+
+:bind_dn and :password is the default credentials to perform user lookup.
+  most LDAP servers require that you supply a complete DN as a binding-credential, along with an authenticator
+  such as a password. But for many applications, you often donâ€™t have a full DN to identify the user. 
+  You usually get a simple identifier like a username or an email address, along with a password. 
+  Since many LDAP servers don't allow anonymous access, search function will require a bound connection, 
+  :bind_dn and :password will be required for searching on the username or email to retrieve the DN attribute 
+  for the user. If the LDAP server allows anonymous access, you don't need to provide these two parameters.
+
+:uid is the LDAP attribute name for the user name in the login form. 
+  typically AD would be 'sAMAccountName' or 'UserPrincipalName', while OpenLDAP is 'uid'.
+
+:filter is the LDAP filter used to search the user entry. It can be used in place of :uid for more flexibility.
+  `%{username}` will be replaced by the user name processed by :name_proc.
+
+:name_proc allows you to match the user name entered with the format of the :uid attributes. 
+  For example, value of 'sAMAccountName' in AD contains only the windows user name. If your user prefers using 
+  email to login, a name_proc as above will trim the email string down to just the windows login name. 
+  In summary, use :name_proc to fill the gap between the submitted username and LDAP uid attribute value.
+ 
+:try_sasl and :sasl_mechanisms are optional. :try_sasl [true | false], :sasl_mechanisms ['DIGEST-MD5' | 'GSS-SPNEGO']
+  Use them to initialize a SASL connection to server. If you are not familiar with these authentication methods, 
+  please just avoid them.
+
+Direct users to '/auth/ldap' to have them authenticated via your company's LDAP server.
+
+
+## License
+
+Copyright (C) 2011 by Ping Yu and Intridea, Inc.
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE.
diff --git a/Rakefile b/Rakefile
new file mode 100644
index 0000000..d2dc1d6
--- /dev/null
+++ b/Rakefile
@@ -0,0 +1,9 @@
+#!/usr/bin/env rake
+require "bundler/gem_tasks"
+require 'rspec/core/rake_task'
+
+desc 'Default: run specs.'
+task :default => :spec
+
+desc "Run specs"
+RSpec::Core::RakeTask.new
diff --git a/lib/omniauth-ldap.rb b/lib/omniauth-ldap.rb
new file mode 100644
index 0000000..e2eb5b4
--- /dev/null
+++ b/lib/omniauth-ldap.rb
@@ -0,0 +1,4 @@
+require "omniauth-ldap/version"
+require "omniauth-ldap/adaptor"
+require 'omniauth/strategies/ldap'
+
diff --git a/lib/omniauth-ldap/adaptor.rb b/lib/omniauth-ldap/adaptor.rb
new file mode 100644
index 0000000..fd1a333
--- /dev/null
+++ b/lib/omniauth-ldap/adaptor.rb
@@ -0,0 +1,147 @@
+#this code borrowed pieces from activeldap and net-ldap
+
+require 'rack'
+require 'net/ldap'
+require 'net/ntlm'
+require 'sasl'
+require 'kconv'
+module OmniAuth
+  module LDAP
+    class Adaptor
+      class LdapError < StandardError; end
+      class ConfigurationError < StandardError; end
+      class AuthenticationError < StandardError; end
+      class ConnectionError < StandardError; end
+
+      VALID_ADAPTER_CONFIGURATION_KEYS = [:host, :port, :method, :bind_dn, :password, :try_sasl, :sasl_mechanisms, :uid, :base, :allow_anonymous, :filter]
+
+      # A list of needed keys. Possible alternatives are specified using sub-lists.
+      MUST_HAVE_KEYS = [:host, :port, :method, [:uid, :filter], :base]
+
+      METHOD = {
+        :ssl => :simple_tls,
+        :tls => :start_tls,
+        :plain => nil,
+      }
+
+      attr_accessor :bind_dn, :password
+      attr_reader :connection, :uid, :base, :auth, :filter
+      def self.validate(configuration={})
+        message = []
+        MUST_HAVE_KEYS.each do |names|
+          names = [names].flatten
+          missing_keys = names.select{|name| configuration[name].nil?}
+          if missing_keys == names
+            message << names.join(' or ')
+          end
+        end
+        raise ArgumentError.new(message.join(",") +" MUST be provided") unless message.empty?
+      end
+      def initialize(configuration={})
+        Adaptor.validate(configuration)
+        @configuration = configuration.dup
+        @configuration[:allow_anonymous] ||= false
+        @logger = @configuration.delete(:logger)
+        VALID_ADAPTER_CONFIGURATION_KEYS.each do |name|
+          instance_variable_set("@#{name}", @configuration[name])
+        end
+        method = ensure_method(@method)
+        config = {
+          :host => @host,
+          :port => @port,
+          :base => @base
+        }
+        @bind_method = @try_sasl ? :sasl : (@allow_anonymous||!@bind_dn||!@password ? :anonymous : :simple)
+
+
+        @auth = sasl_auths({:username => @bind_dn, :password => @password}).first if @bind_method == :sasl
+        @auth ||= { :method => @bind_method,
+                    :username => @bind_dn,
+                    :password => @password
+                  }
+        config[:auth] = @auth
+        @connection = Net::LDAP.new(config)
+        @connection.encryption(method)
+      end
+
+      #:base => "dc=yourcompany, dc=com",
+      # :filter => "(mail=#{user})",
+      # :password => psw
+      def bind_as(args = {})
+        result = false
+        @connection.open do |me|
+          rs = me.search args
+          if rs and rs.first and dn = rs.first.dn
+            password = args[:password]
+            method = args[:method] || @method
+            password = password.call if password.respond_to?(:call)
+            if method == 'sasl'
+            result = rs.first if me.bind(sasl_auths({:username => dn, :password => password}).first)
+            else
+            result = rs.first if me.bind(:method => :simple, :username => dn,
+                                :password => password)
+            end
+          end
+        end
+        result
+      end
+
+      private
+      def ensure_method(method)
+          method ||= "plain"
+          normalized_method = method.to_s.downcase.to_sym
+          return METHOD[normalized_method] if METHOD.has_key?(normalized_method)
+
+          available_methods = METHOD.keys.collect {|m| m.inspect}.join(", ")
+          format = "%s is not one of the available connect methods: %s"
+          raise ConfigurationError, format % [method.inspect, available_methods]
+      end
+
+      def sasl_auths(options={})
+        auths = []
+        sasl_mechanisms = options[:sasl_mechanisms] || @sasl_mechanisms
+        sasl_mechanisms.each do |mechanism|
+          normalized_mechanism = mechanism.downcase.gsub(/-/, '_')
+          sasl_bind_setup = "sasl_bind_setup_#{normalized_mechanism}"
+          next unless respond_to?(sasl_bind_setup, true)
+          initial_credential, challenge_response = send(sasl_bind_setup, options)
+          auths << {
+            :method => :sasl,
+            :initial_credential => initial_credential,
+            :mechanism => mechanism,
+            :challenge_response => challenge_response
+          }
+        end
+        auths
+      end
+
+      def sasl_bind_setup_digest_md5(options)
+        bind_dn = options[:username]
+        initial_credential = ""
+        challenge_response = Proc.new do |cred|
+          pref = SASL::Preferences.new :digest_uri => "ldap/#{@host}", :username => bind_dn, :has_password? => true, :password => options[:password]
+          sasl = SASL.new("DIGEST-MD5", pref)
+          response = sasl.receive("challenge", cred)
+          response[1]
+        end
+        [initial_credential, challenge_response]
+      end
+
+      def sasl_bind_setup_gss_spnego(options)
+        bind_dn = options[:username]
+        psw = options[:password]
+        raise LdapError.new( "invalid binding information" ) unless (bind_dn && psw)
+
+        nego = proc {|challenge|
+          t2_msg = Net::NTLM::Message.parse( challenge )
+          bind_dn, domain = bind_dn.split('\\').reverse
+          t2_msg.target_name = Net::NTLM::encode_utf16le(domain) if domain
+          t3_msg = t2_msg.response( {:user => bind_dn, :password => psw}, {:ntlmv2 => true} )
+          t3_msg.serialize
+        }
+        [Net::NTLM::Message::Type1.new.serialize, nego]
+      end
+
+    end
+  end
+end
diff --git a/lib/omniauth-ldap/version.rb b/lib/omniauth-ldap/version.rb
new file mode 100644
index 0000000..507a2af
--- /dev/null
+++ b/lib/omniauth-ldap/version.rb
@@ -0,0 +1,5 @@
+module OmniAuth
+  module LDAP
+    VERSION = "2.0.0"
+  end
+end
diff --git a/lib/omniauth/strategies/ldap.rb b/lib/omniauth/strategies/ldap.rb
new file mode 100644
index 0000000..9a4d880
--- /dev/null
+++ b/lib/omniauth/strategies/ldap.rb
@@ -0,0 +1,101 @@
+require 'omniauth'
+
+module OmniAuth
+  module Strategies
+    class LDAP
+      include OmniAuth::Strategy
+      @@config = {
+        'name' => 'cn',
+        'first_name' => 'givenName',
+        'last_name' => 'sn',
+        'email' => ['mail', "email", 'userPrincipalName'],
+        'phone' => ['telephoneNumber', 'homePhone', 'facsimileTelephoneNumber'],
+        'mobile' => ['mobile', 'mobileTelephoneNumber'],
+        'nickname' => ['uid', 'userid', 'sAMAccountName'],
+        'title' => 'title',
+        'location' => {"%0, %1, %2, %3 %4" => [['address', 'postalAddress', 'homePostalAddress', 'street', 'streetAddress'], ['l'], ['st'],['co'],['postOfficeBox']]},
+        'uid' => 'dn',
+        'url' => ['wwwhomepage'],
+        'image' => 'jpegPhoto',
+        'description' => 'description'
+      }
+      option :title, "LDAP Authentication" #default title for authentication form
+      option :port, 389
+      option :method, :plain
+      option :uid, 'sAMAccountName'
+      option :name_proc, lambda {|n| n}
+
+      def request_phase
+        OmniAuth::LDAP::Adaptor.validate @options
+        f = OmniAuth::Form.new(:title => (options[:title] || "LDAP Authentication"), :url => callback_path)
+        f.text_field 'Login', 'username'
+        f.password_field 'Password', 'password'
+        f.button "Sign In"
+        f.to_response
+      end
+
+      def callback_phase
+        @adaptor = OmniAuth::LDAP::Adaptor.new @options
+
+        return fail!(:missing_credentials) if missing_credentials?
+        begin
+          @ldap_user_info = @adaptor.bind_as(:filter => filter(@adaptor), :size => 1, :password => request['password'])
+          return fail!(:invalid_credentials) if !@ldap_user_info
+
+          @user_info = self.class.map_user(@@config, @ldap_user_info)
+          super
+        rescue Exception => e
+          return fail!(:ldap_error, e)
+        end
+      end
+
+      def filter adaptor
+        if adaptor.filter and !adaptor.filter.empty?
+          Net::LDAP::Filter.construct(adaptor.filter % {username: @options[:name_proc].call(request['username'])})
+        else
+          Net::LDAP::Filter.eq(adaptor.uid, @options[:name_proc].call(request['username']))
+        end
+      end
+
+      uid {
+        @user_info["uid"]
+      }
+      info {
+        @user_info
+      }
+      extra {
+        { :raw_info => @ldap_user_info }
+      }
+
+      def self.map_user(mapper, object)
+        user = {}
+        mapper.each do |key, value|
+          case value
+          when String
+            user[key] = object[value.downcase.to_sym].first if object.respond_to? value.downcase.to_sym
+          when Array
+            value.each {|v| (user[key] = object[v.downcase.to_sym].first; break;) if object.respond_to? v.downcase.to_sym}
+          when Hash
+            value.map do |key1, value1|
+              pattern = key1.dup
+              value1.each_with_index do |v,i|
+                part = ''; v.collect(&:downcase).collect(&:to_sym).each {|v1| (part = object[v1].first; break;) if object.respond_to? v1}
+                pattern.gsub!("%#{i}",part||'')
+              end
+              user[key] = pattern
+            end
+          end
+        end
+        user
+      end
+
+      protected
+
+      def missing_credentials?
+        request['username'].nil? or request['username'].empty? or request['password'].nil? or request['password'].empty?
+      end # missing_credentials?
+    end
+  end
+end
+
+OmniAuth.config.add_camelization 'ldap', 'LDAP'
diff --git a/omniauth-ldap.gemspec b/omniauth-ldap.gemspec
new file mode 100644
index 0000000..309f3ab
--- /dev/null
+++ b/omniauth-ldap.gemspec
@@ -0,0 +1,26 @@
+# -*- encoding: utf-8 -*-
+require File.expand_path('../lib/omniauth-ldap/version', __FILE__)
+
+Gem::Specification.new do |gem|
+  gem.authors       = ["Ping Yu", "Tom Milewski"]
+  gem.email         = ["ping@intridea.com", "tmilewski@gmail.com"]
+  gem.description   = %q{A LDAP strategy for OmniAuth.}
+  gem.summary       = %q{A LDAP strategy for OmniAuth.}
+  gem.homepage      = "https://github.com/intridea/omniauth-ldap"
+  gem.license       = "MIT"
+
+  gem.add_runtime_dependency     'omniauth', '~> 1.8.1'
+  gem.add_runtime_dependency     'net-ldap', '~> 0.16'
+  gem.add_runtime_dependency     'pyu-ruby-sasl', '~> 0.0.3.3'
+  gem.add_runtime_dependency     'rubyntlm', '~> 0.6.2'
+  gem.add_development_dependency 'rspec', '~> 3.0'
+  gem.add_development_dependency 'simplecov'
+  gem.add_development_dependency 'rack-test'
+
+  gem.executables   = `git ls-files -- bin/*`.split("\n").map{ |f| File.basename(f) }
+  gem.files         = `git ls-files`.split("\n")
+  gem.test_files    = `git ls-files -- {test,spec,features}/*`.split("\n")
+  gem.name          = "omniauth-ldap"
+  gem.require_paths = ["lib"]
+  gem.version       = OmniAuth::LDAP::VERSION
+end
diff --git a/spec/omniauth-ldap/adaptor_spec.rb b/spec/omniauth-ldap/adaptor_spec.rb
new file mode 100644
index 0000000..a4200c0
--- /dev/null
+++ b/spec/omniauth-ldap/adaptor_spec.rb
@@ -0,0 +1,86 @@
+require 'spec_helper'
+describe "OmniAuth::LDAP::Adaptor" do
+
+  describe 'initialize' do
+    it 'should throw exception when must have field is not set' do
+      #[:host, :port, :method, :bind_dn]
+      expect {
+        OmniAuth::LDAP::Adaptor.new({ host: "192.168.1.145", method: 'plain' })
+      }.to raise_error(ArgumentError)
+    end
+
+    it 'should throw exception when method is not supported' do
+      expect {
+        OmniAuth::LDAP::Adaptor.new({ host: "192.168.1.145", method: 'myplain', uid: 'uid', port: 389, base: 'dc=com' })
+      }.to raise_error(OmniAuth::LDAP::Adaptor::ConfigurationError)
+    end
+
+    it 'should setup ldap connection with anonymous' do
+      adaptor = OmniAuth::LDAP::Adaptor.new({ host: "192.168.1.145", method: 'plain', base: 'dc=intridea, dc=com', port: 389, uid: 'sAMAccountName' })
+      expect(adaptor.connection).to_not be_nil
+      expect(adaptor.connection.host).to eq '192.168.1.145'
+      expect(adaptor.connection.port).to eq 389
+      expect(adaptor.connection.base).to eq 'dc=intridea, dc=com'
+      expect(adaptor.connection.instance_variable_get('@auth')).to eq({ method: :anonymous, username: nil, password: nil })
+    end
+
+    it 'should setup ldap connection with simple' do
+      adaptor = OmniAuth::LDAP::Adaptor.new({ host: "192.168.1.145", method: 'plain', base: 'dc=intridea, dc=com', port: 389, uid: 'sAMAccountName', bind_dn: 'bind_dn', password: 'password' })
+      expect(adaptor.connection).to_not be_nil
+      expect(adaptor.connection.host).to eq '192.168.1.145'
+      expect(adaptor.connection.port).to eq 389
+      expect(adaptor.connection.base).to eq 'dc=intridea, dc=com'
+      expect(adaptor.connection.instance_variable_get('@auth')).to eq({ method: :simple, username: 'bind_dn', password: 'password' })
+    end
+
+    it 'should setup ldap connection with sasl-md5' do
+      adaptor = OmniAuth::LDAP::Adaptor.new({ host: "192.168.1.145", method: 'plain', base: 'dc=intridea, dc=com', port: 389, uid: 'sAMAccountName', try_sasl: true, sasl_mechanisms: ["DIGEST-MD5"], bind_dn: 'bind_dn', password: 'password' })
+      expect(adaptor.connection).to_not be_nil
+      expect(adaptor.connection.host).to eq '192.168.1.145'
+      expect(adaptor.connection.port).to eq 389
+      expect(adaptor.connection.base).to eq 'dc=intridea, dc=com'
+      expect(adaptor.connection.instance_variable_get('@auth')[:method]).to eq :sasl
+      expect(adaptor.connection.instance_variable_get('@auth')[:mechanism]).to eq 'DIGEST-MD5'
+      expect(adaptor.connection.instance_variable_get('@auth')[:initial_credential]).to eq ''
+      expect(adaptor.connection.instance_variable_get('@auth')[:challenge_response]).to_not be_nil
+    end
+
+    it 'should setup ldap connection with sasl-gss' do
+      adaptor = OmniAuth::LDAP::Adaptor.new({host: "192.168.1.145", method: 'plain', base: 'dc=intridea, dc=com', port: 389, uid: 'sAMAccountName', try_sasl: true, sasl_mechanisms: ["GSS-SPNEGO"], bind_dn: 'bind_dn', password: 'password'})
+      expect(adaptor.connection).to_not be_nil
+      expect(adaptor.connection.host).to eq '192.168.1.145'
+      expect(adaptor.connection.port).to eq 389
+      expect(adaptor.connection.base).to eq 'dc=intridea, dc=com'
+      expect(adaptor.connection.instance_variable_get('@auth')[:method]).to eq :sasl
+      expect(adaptor.connection.instance_variable_get('@auth')[:mechanism]).to eq 'GSS-SPNEGO'
+      expect(adaptor.connection.instance_variable_get('@auth')[:initial_credential]).to match /^NTLMSSP/
+      expect(adaptor.connection.instance_variable_get('@auth')[:challenge_response]).to_not be_nil
+    end
+
+    it 'should set the encryption method correctly' do
+      adaptor = OmniAuth::LDAP::Adaptor.new({ host: "192.168.1.145", method: 'tls', base: 'dc=intridea, dc=com', port: 389, uid: 'sAMAccountName' })
+      expect(adaptor.connection.instance_variable_get('@encryption')).to include method: :start_tls
+    end
+  end
+
+  describe 'bind_as' do
+    let(:args) { { :filter => Net::LDAP::Filter.eq('sAMAccountName', 'username'), :password => 'password', :size => 1 } }
+    let(:rs) { Struct.new(:dn).new('new dn') }
+
+    it 'should bind simple' do
+      adaptor = OmniAuth::LDAP::Adaptor.new({ host: "192.168.1.126", method: 'plain', base: 'dc=score, dc=local', port: 389, uid: 'sAMAccountName', bind_dn: 'bind_dn', password: 'password' })
+      expect(adaptor.connection).to receive(:open).and_yield(adaptor.connection)
+      expect(adaptor.connection).to receive(:search).with(args).and_return([rs])
+      expect(adaptor.connection).to receive(:bind).with({ :username => 'new dn', :password => args[:password], :method => :simple }).and_return(true)
+      expect(adaptor.bind_as(args)).to eq rs
+    end
+
+    it 'should bind sasl' do
+      adaptor = OmniAuth::LDAP::Adaptor.new({ host: "192.168.1.145", method: 'plain', base: 'dc=intridea, dc=com', port: 389, uid: 'sAMAccountName', try_sasl: true, sasl_mechanisms: ["GSS-SPNEGO"], bind_dn: 'bind_dn', password: 'password' })
+      expect(adaptor.connection).to receive(:open).and_yield(adaptor.connection)
+      expect(adaptor.connection).to receive(:search).with(args).and_return([rs])
+      expect(adaptor.connection).to receive(:bind).and_return(true)
+      expect(adaptor.bind_as(args)).to eq rs
+    end
+  end
+end
diff --git a/spec/omniauth/strategies/ldap_spec.rb b/spec/omniauth/strategies/ldap_spec.rb
new file mode 100644
index 0000000..7c17c23
--- /dev/null
+++ b/spec/omniauth/strategies/ldap_spec.rb
@@ -0,0 +1,200 @@
+require 'spec_helper'
+describe "OmniAuth::Strategies::LDAP" do
+  # :title => "My LDAP",
+  # :host => '10.101.10.1',
+  # :port => 389,
+  # :method => :plain,
+  # :base => 'dc=intridea, dc=com',
+  # :uid => 'sAMAccountName',
+  # :name_proc => Proc.new {|name| name.gsub(/@.*$/,'')}
+  # :bind_dn => 'default_bind_dn'
+  # :password => 'password'
+  class MyLdapProvider < OmniAuth::Strategies::LDAP; end
+
+  let(:app) do
+    Rack::Builder.new {
+      use OmniAuth::Test::PhonySession
+      use MyLdapProvider, :name => 'ldap', :title => 'MyLdap Form', :host => '192.168.1.145', :base => 'dc=score, dc=local', :name_proc => Proc.new {|name| name.gsub(/@.*$/,'')}
+      run lambda { |env| [404, {'Content-Type' => 'text/plain'}, [env.key?('omniauth.auth').to_s]] }
+    }.to_app
+  end
+
+  let(:session) do
+    last_request.env['rack.session']
+  end
+
+  it 'should add a camelization for itself' do
+    expect(OmniAuth::Utils.camelize('ldap')).to eq 'LDAP'
+  end
+
+  describe '/auth/ldap' do
+    before(:each){ get '/auth/ldap' }
+
+    it 'should display a form' do
+      expect(last_response.status).to eq 200
+      expect(last_response.body).to include("<form")
+    end
+
+    it 'should have the callback as the action for the form' do
+      expect(last_response.body).to include("action='/auth/ldap/callback'")
+    end
+
+    it 'should have a text field for each of the fields' do
+      expect(last_response.body.scan('<input').size).to eq 2
+    end
+    it 'should have a label of the form title' do
+      expect(last_response.body.scan('MyLdap Form').size).to be > 1
+    end
+  end
+
+  describe 'post /auth/ldap/callback' do
+    before(:each) do
+      @adaptor = double(OmniAuth::LDAP::Adaptor, {:uid => 'ping'})
+
+      allow(@adaptor).to receive(:filter)
+      allow(OmniAuth::LDAP::Adaptor).to receive(:new) { @adaptor }
+    end
+
+    context 'failure' do
+      before(:each) do
+        allow(@adaptor).to receive(:bind_as) { false }
+      end
+
+      context "when username is not preset" do
+        it 'should redirect to error page' do
+          post('/auth/ldap/callback', {})
+
+          # expect(last_response).to be redirect
+          expect(last_response).to be_redirect
+          expect(last_response.headers['Location']).to match %r{missing_credentials}
+        end
+      end
+
+      context "when username is empty" do
+        it 'should redirect to error page' do
+          post('/auth/ldap/callback', { username: "" })
+
+          expect(last_response).to be_redirect
+          expect(last_response.headers['Location']).to match %r{missing_credentials}
+        end
+      end
+
+      context "when username is present" do
+        context "and password is not preset" do
+          it 'should redirect to error page' do
+            post('/auth/ldap/callback', { username: "ping" })
+
+            expect(last_response).to be_redirect
+            expect(last_response.headers['Location']).to match %r{missing_credentials}
+          end
+        end
+
+        context "and password is empty" do
+          it 'should redirect to error page' do
+            post('/auth/ldap/callback', { username: "ping", password: "" })
+
+            expect(last_response).to be_redirect
+            expect(last_response.headers['Location']).to match %r{missing_credentials}
+          end
+        end
+      end
+
+      context "when username and password are present" do
+        context "and bind on LDAP server failed" do
+          it 'should redirect to error page' do
+            post('/auth/ldap/callback', { username: 'ping', password: 'password' })
+
+            expect(last_response).to be_redirect
+            expect(last_response.headers['Location']).to match %r{invalid_credentials}
+          end
+          context 'and filter is set' do
+            it 'should bind with filter' do
+              allow(@adaptor).to receive(:filter) { 'uid=%{username}' }
+              expect(Net::LDAP::Filter).to receive(:construct).with('uid=ping')
+              post('/auth/ldap/callback', { username: 'ping', password: 'password' })
+
+              expect(last_response).to be_redirect
+              expect(last_response.headers['Location']).to match %r{invalid_credentials}
+            end
+          end
+
+        end
+
+        context "and communication with LDAP server caused an exception" do
+          before :each do
+            allow(@adaptor).to receive(:bind_as).and_throw(Exception.new('connection_error'))
+          end
+
+          it 'should redirect to error page' do
+            post('/auth/ldap/callback', { username: "ping", password: "password" })
+
+            expect(last_response).to be_redirect
+            expect(last_response.headers['Location']).to match %r{ldap_error}
+          end
+        end
+      end
+    end
+
+    context 'success' do
+      let(:auth_hash){ last_request.env['omniauth.auth'] }
+
+      before(:each) do
+        allow(@adaptor).to receive(:filter)
+        allow(@adaptor).to receive(:bind_as) { Net::LDAP::Entry.from_single_ldif_string(
+      %Q{dn: cn=ping, dc=intridea, dc=com
+mail: ping@intridea.com
+givenname: Ping
+sn: Yu
+telephonenumber: 555-555-5555
+mobile: 444-444-4444
+uid: ping
+title: dev
+address: k street
+l: Washington
+st: DC
+co: U.S.A
+postofficebox: 20001
+wwwhomepage: www.intridea.com
+jpegphoto: http://www.intridea.com/ping.jpg
+description: omniauth-ldap
+}
+    )}
+      end
+
+      it 'should not redirect to error page' do
+        post('/auth/ldap/callback', {:username => 'ping', :password => 'password'})
+        expect(last_response).to_not be_redirect
+      end
+
+      context 'and filter is set' do
+        it 'should bind with filter' do
+          allow(@adaptor).to receive(:filter) { 'uid=%{username}' }
+          expect(Net::LDAP::Filter).to receive(:construct).with('uid=ping')
+          post('/auth/ldap/callback', { username: 'ping', password: 'password' })
+
+          expect(last_response).to_not be_redirect
+        end
+      end
+
+      it 'should map user info to Auth Hash' do
+        post('/auth/ldap/callback', { username: 'ping', password: 'password' })
+
+        expect(auth_hash.uid).to eq 'cn=ping, dc=intridea, dc=com'
+
+        info = auth_hash.info
+
+        expect(info.email).to eq 'ping@intridea.com'
+        expect(info.first_name).to eq 'Ping'
+        expect(info.last_name).to eq 'Yu'
+        expect(info.phone).to eq '555-555-5555'
+        expect(info.mobile).to eq '444-444-4444'
+        expect(info.nickname).to eq 'ping'
+        expect(info.title).to eq 'dev'
+        expect(info.location).to eq 'k street, Washington, DC, U.S.A 20001'
+        expect(info.url).to eq 'www.intridea.com'
+        expect(info.image).to eq 'http://www.intridea.com/ping.jpg'
+        expect(info.description).to eq 'omniauth-ldap'
+      end
+    end
+  end
+end
diff --git a/spec/spec_helper.rb b/spec/spec_helper.rb
new file mode 100644
index 0000000..c0facec
--- /dev/null
+++ b/spec/spec_helper.rb
@@ -0,0 +1,14 @@
+$:.unshift File.expand_path('..', __FILE__)
+$:.unshift File.expand_path('../../lib', __FILE__)
+require 'simplecov'
+SimpleCov.start
+require 'rspec'
+require 'rack/test'
+require 'omniauth'
+require 'omniauth-ldap'
+
+RSpec.configure do |config|
+  config.include Rack::Test::Methods
+  config.extend  OmniAuth::Test::StrategyMacros, :type => :strategy
+end
+
--
Working Copy 4.1.8